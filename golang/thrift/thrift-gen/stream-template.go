package main

// Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var serviceStreamTmpl = `
// Autogenerated by thrift-gen. Do not modify.

package {{ .Package }}

import (
  "fmt"
  "io"

  athrift "github.com/apache/thrift/lib/go/thrift"
  "github.com/uber/tchannel/golang"
  "github.com/uber/tchannel/golang/thrift"
)

{{ range .Services }}
// {{ .ServerInterface }} is the interface that must be implemented by a handler.
type {{ .ServerInterface }} interface {
  {{ .Interface }}

	{{ range .StreamingMethods }}
		{{ .Name }}({{ .StreamingServerArgList }}) {{ .StreamingServerRetType }}
	{{ end }}
}

// {{ .ClientInterface }} is the interface used to make remote calls.
type {{ .ClientInterface }} interface {
  {{ .Interface }}

  {{ range .StreamingMethods }}
    {{ .Name }}({{ .StreamingClientArgList }}) {{ .StreamingClientRetType }}
  {{ end }}
}
{{ end }}


{{ range $svc := .Services }}

type {{ .StreamingServerStruct }} struct {
  handler {{ .ServerInterface }}

  // TODO(prashant): Remove this.
  client thrift.TChanStreamingClient
}

// NewS{{ .ServerInterface }} returns a {{ .ServerInterface }} used to route requests to
// the given handler.
func NewS{{ .ServerInterface }}(handler {{ .ServerInterface }}, client thrift.TChanStreamingClient) thrift.TChanStreamingServer {
  return &{{ .StreamingServerStruct }}{handler, client}
}

func (s *{{ .StreamingServerStruct }}) Service() string {
	return "{{ .ThriftName }}"
}

func (s *{{ .StreamingServerStruct }}) Methods() []string {
	return []string{
    {{ range .StreamingMethods }}
			"{{ .ThriftName }}",
		{{ end }}
	}
}

func (s *{{ .StreamingServerStruct }}) Handle(ctx thrift.Context, call *tchannel.InboundCall) error {
  arg3Reader, err := call.Arg3Reader()
  if err != nil {
    return err
  }

  methodName := string(call.Operation())
  switch methodName {
	{{ range .StreamingMethods }}
  case "{{ $svc.ThriftName }}::{{ .ThriftName }}":
			return s.{{ .HandleFunc }}(ctx, call, arg3Reader)
	{{ end }}
	default:
    return fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

{{ range .StreamingMethods }}

func (s *{{ $svc.StreamingServerStruct }}) handle{{ .Name }}(ctx thrift.Context, tcall *tchannel.InboundCall, arg3Reader io.ReadCloser) error {
  call := &{{ .InCallName }}{
    client: s.client,
    call: tcall,
    ctx: ctx,
  }

  {{ if .StreamingArg }}
  call.reader = arg3Reader
  {{ else }}
  var req {{ .ArgsType }}
  if err := s.client.ReadStruct(arg3Reader, func(protocol athrift.TProtocol) error {
    return req.Read(protocol)
  }); err != nil {
    return err
  }
  {{ end }}


  {{ if .StreamingServerHasResult }}
  res, err :=
  {{ else }}
  err :=
  {{ end }}
    s.handler.{{ .Name }}({{ .StreamingCallList "req" "call"}})
  if err != nil {
    // TODO: encode any Thrift exceptions here.
    return err
  }

  if err := call.checkWriter(); err != nil {
    return err
  }

  {{ if .StreamingServerHasResult }}
  if err := s.client.WriteStruct(call.writer, res); err != nil {
    return err
  }
  {{ end }}

  // TODO: we may want to Close the writer if it's not already closed.

  return nil
}

{{ end }}

type {{ .StreamingClientStruct }} struct {
  client thrift.TChanStreamingClient
}

// NewS{{ .ClientInterface }} returns a {{ .ClientInterface }} that makes remote calls.
func NewS{{ .ClientInterface }}(client thrift.TChanStreamingClient) {{ .ClientInterface }}{
  return &{{ .StreamingClientStruct }}{client}
}

{{ range .StreamingMethods }}

func (c *{{ $svc.StreamingClientStruct }}) {{ .Name }}({{ .StreamingClientArgList }}) {{ .StreamingClientRetType }} {
  call, writer, err := c.client.StartCall(ctx, "{{ $svc.ThriftName }}::{{ .ThriftName }}")
  if err != nil {
    return nil, err
  }

  outCall := &{{ .OutCallName }}{
    client: c.client,
    call: call,
  }

  {{ if not .StreamingArg }}
  args := {{ .ArgsType }}{
    {{ range .Arguments }}
      {{ .ArgStructName }}: {{ .Name }},
    {{ end }}
  }
  if err := c.client.WriteStruct(writer, &args); err != nil {
    return nil, err
  }

  {{ else }}
  outCall.writer = writer
  {{ end }}

  return outCall, nil
}

{{ end }}

{{ range .StreamingMethods }}
  // {{ .InCallName }} is the object used to stream arguments and write
  // response headers for incoming calls.
  type {{ .InCallName }} struct {
		client thrift.TChanStreamingClient
		call   *tchannel.InboundCall
    ctx    thrift.Context

		{{ if .StreamingArg }}
		reader io.ReadCloser
		{{ end }}

		writer tchannel.ArgWriter
	}

	{{ if .StreamingArg }}

	// Read returns the next argument, if any is available. If there are no more
  // arguments left, it will return io.EOF.
	func (c *{{ .InCallName }}) Read() (*{{ .StreamingArgType }}, error) {
		var req {{ .StreamingArgType }}
		if err := c.client.ReadStreamStruct(c.reader, func(protocol athrift.TProtocol) error {
			return req.Read(protocol)
		}); err != nil {
			return nil, err
		}

		return &req, nil
	}

  {{ end }}

  // SetResponseHeaders sets the response headers. This must be called before any
  // streaming responses are sent.
	func (c *{{ .InCallName }}) SetResponseHeaders(headers map[string]string) error {
		if c.writer != nil {
			// arg3 is already being written, headers must be set first
			return fmt.Errorf("cannot set headers after writing streaming responses")
		}

    c.ctx.SetResponseHeaders(headers)
    return nil
	}

  func (c *{{ .InCallName }}) writeResponseHeaders() error {
		if c.writer != nil {
			// arg3 is already being written, headers must be set first
			return fmt.Errorf("cannot set headers after writing streaming responses")
		}

		// arg2 writer should be used to write headers
		arg2Writer, err := c.call.Response().Arg2Writer()
		if err != nil {
			return err
		}

    headers := c.ctx.ResponseHeaders()
		if err := c.client.WriteHeaders(arg2Writer, headers); err != nil {
      return err
    }

    return arg2Writer.Close()
	}

  // checkWriter creates the arg3 writer if it has not been created.
  // Before the arg3 writer is created, response headers are sent.
	func (c *{{ .InCallName }}) checkWriter() error {
		if c.writer == nil {
      if err := c.writeResponseHeaders(); err != nil {
        return err
      }

			writer, err := c.call.Response().Arg3Writer()
			if err != nil {
				return err
			}
			c.writer = writer
		}
		return nil
	}

	{{ if .StreamingRes }}

  // Write writes a result to the response stream. The written items may not
  // be sent till Flush or Done is called.
	func (c *{{ .InCallName }}) Write(arg *{{ .StreamingResType }}) error {
		if err := c.checkWriter(); err != nil {
			return err
		}
		return c.client.WriteStreamStruct(c.writer, arg)
	}

  // Flush flushes headers (if they have not yet been sent) and any written results.
	func (c *{{ .InCallName }}) Flush() error {
		if err := c.checkWriter(); err != nil {
			return err
		}
		return c.writer.Flush()
	}

  // Done closes the response stream and should be called after all results have been written.
	func (c *{{ .InCallName }}) Done() error {
		if err := c.checkWriter(); err != nil {
			return err
		}
		return c.writer.Close()
	}

	{{ end }}

  // {{ .OutCallName }} is the object used to stream arguments/results and
  // read response headers for outgoing calls.
	type {{ .OutCallName }} struct {
		client thrift.TChanStreamingClient
		call *tchannel.OutboundCall
		responseHeaders map[string]string
		reader io.ReadCloser
		{{ if .StreamingArg }}
		writer tchannel.ArgWriter
		{{ end }}
	}

	{{ if .StreamingArg }}
  // Write writes an argument to the request stream. The written items may not
  // be sent till Flush or Done is called.
	func (c *{{ .OutCallName }}) Write(arg *{{ .StreamingArgType }}) error {
		return c.client.WriteStreamStruct(c.writer, arg)
	}

  // Flush flushes all written arguments.
	func (c *{{ .OutCallName }}) Flush() error {
		return c.writer.Flush()
	}


  // Done closes the request stream and should be called after all arguments have been written.
  {{ if .OutDoneHasReturn }}
  // Done also returns the non-streaming response
  {{ end }}
	func (c *{{ .OutCallName }}) Done() {{ .OutDoneRetType }} {
		if err := c.writer.Close(); err != nil {
      return {{ .OutDoneWrapErr "err" }}
		}

		{{ if .StreamingRes }}
			return nil
		{{ else }}
      if err := c.checkReader(); err != nil {
        return {{ .OutDoneWrapErr "err" }}
      }
			{{ if not .HasReturn }}
        return {{ .OutDoneWrapErr "c.reader.Close()" }}
      {{ else }}

      var resp {{ .ResultType }}
      if err := c.client.ReadStruct(c.reader, func(protocol athrift.TProtocol) error {
        return resp.Read(protocol)
      }); err != nil {
        return nil, err
      }
      return resp.GetSuccess(), nil
      {{ end }}
      {{ end }}
	}
	{{ end }}

  func (c *{{ .OutCallName }}) checkReader() error {
		if c.reader == nil {
			arg2Reader, err := c.call.Response().Arg2Reader()
			if err != nil {
				return err
			}

			c.responseHeaders, err = c.client.ReadHeaders(arg2Reader)
			if err != nil {
				return err
			}
			if err := arg2Reader.Close(); err != nil {
				return err
			}

			reader, err := c.call.Response().Arg3Reader()
			if err != nil {
				return err
			}

			c.reader = reader
		}
		return nil
	}

	{{ if .StreamingRes}}
  // Read returns the next result, if any is available. If there are no more
  // results left, it will return io.EOF.
	func (c *{{ .OutCallName }}) Read() (*{{ .StreamingResType }}, error) {
    if err := c.checkReader(); err != nil {
      return nil, err
    }
    var res {{ .StreamingResType }}
    if err := c.client.ReadStreamStruct(c.reader, func(protocol athrift.TProtocol) error {
  		return res.Read(protocol)
  	}); err != nil {
  		return nil, err
  	}

  	return &res, nil
	}
	{{ end }}

  // ResponseHeaders returns the response headers sent from the server. This will
  // block until server headers have been received.
  func (c *{{ .OutCallName }}) ResponseHeaders() (map[string]string, error) {
		if err := c.checkReader(); err != nil {
			return nil, err
		}
		return c.responseHeaders, nil
	}

{{ end }}

{{ end }}

`
